#!/usr/bin/env python3
import cmd
import getpass
import os
import pickle
import re
import subprocess

from classes.course import Course
from classes.exceptions import FileNotFoundException, FileNotOwnedException, UnknownPasswordException, \
    AlreadyInListException, ObjectAlreadyExistantException, CommandHasNoArgumentsException, \
    NumberOfArgumentsException, PasswordNotEqualException, CannotDeleteUserException, UnknownObjectNameException, \
    NotInListException
from classes.file import File
from classes.user import Student, Admin


class AdminCli(cmd.Cmd):
    """Cette classe permet de creer une interface en ligne de commande admin personalisee a l'aide du module cmd"""
    intro = "Bienvenue dans le shell CLI admin du projet python 2TL1_09 :\n\nIntroduire help ou ? pour lister les " \
            "commandes disponibles\n\n"

    @staticmethod
    def do_add_teacher(line):
        """
        add_teacher [COURSE_NAME] [TEACHER]

        PRE : line est de type str et correspond a deux sequences de caracteres separees par un espace
                    - la premiere sequence (course_name) correspond a l'intitule du cours concerne
                    - la deuxieme sequence (teacher) correspond au nom complet du professeur que l'on
                        desire ajouter comme titulaire au cours
        POST : le nom du professeur est indique comme titulaire du cours ssi course_name correspond au nom d'un cours
            connu du programme

        :param line: str
            La ligne d'arguments introduite a la suite de l'appel de la fonction do_mv dans l'interface
                en ligne de commande cree par le module cmd
        """

        course_name = line.split()[0]
        teacher = line.split()[1:]
        all_courses = pickle_get_courses()
        try:
            course_instance_id = all_courses["name_id_dict"][course_name]
            course_instance = all_courses["objects_dict"][course_instance_id]
            course_instance.add_teacher(teacher)
        except AlreadyInListException:
            print(f"Le professeur {teacher} est deja titulaire du cours {course_name}")
        except Exception as e:
            print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
        else:
            pickle_save(courses=all_courses)
            print(f"Le proffesseur {teacher} est maintenant titulaire du cours {course_name}")


    @staticmethod
    def do_remove_teacher(line):
        """
        remove_teacher [COURSE_NAME] [TEACHER]

        PRE : line est de type str et correspond a deux sequences de caracteres separees par un espace
                    - la premiere sequence (course_name) correspond a l'intitule du cours concerne
                    - la deuxieme sequence (teacher) correspond au nom complet du professeur que l'on
                        desire retirer de la liste des titulaires
        POST : le nom du professeur est retire de la liste des titulaires du cours ssi course_name correspond
            au nom d'un cours connu du programme

        :param line: str
            La ligne d'arguments introduite a la suite de l'appel de la fonction do_mv dans l'interface
                en ligne de commande cree par le module cmd
        """

        course_name = line.split()[0]
        teacher = line.split()[1:]
        all_courses = pickle_get_courses()
        try:
            course_instance_id = all_courses["name_id_dict"][course_name]
            course_instance = all_courses["objects_dict"][course_instance_id]
            course_instance.remove_teacher(teacher)
        except NotInListException:
            print(f"Le professeur {teacher} n'est pas titulaire du cours {course_name}")
        except Exception as e:
            print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
        else:
            pickle_save(courses=all_courses)
            print(f"Le proffesseur {teacher} n'est maintenant plus titulaire du cours {course_name}")

    @staticmethod
    def do_reset(line):
        """
        reset

        PRE : line est une chaine de caractere vide
        RAISES : CommandHasNoArgumentsException si line n'est pas une chaine de caractere vide

        Methode permettant de reinitialiser la memoire du programme (elle ne contient plus que les root_users)

        :param line: str
            chaine vide car la fonction reset ne demande pas de parametres
        """
        try:
            if line != "":
                raise CommandHasNoArgumentsException
        except CommandHasNoArgumentsException:
            print("La fonction n'accepte aucun argument\nVeuillez reesayer :\n")
        else:
            with open("pickle_saves/id_dict.pkl", 'wb') as id_dict_file:
                id_dict = {"user": 0, "file": 0, "course": 0}
                pickle.dump(id_dict, id_dict_file)

            id_dict = pickle_get_ids()
            user_id_counter = id_dict["user"]

            dax = Student("dax", "Nicolas Daxhelet", "user123", user_id_counter)
            user_id_counter += 1
            daxxra = Admin("daxxra", "Nicolas Daxhelet", "user111", user_id_counter)
            user_id_counter += 1

            greg = Student("greg", "Gregoire Delannoit", "user123", user_id_counter)
            user_id_counter += 1
            the_gregouze = Admin("TheGregouze", "Gregoire Delannoit", "user111", user_id_counter)
            user_id_counter += 1

            id_dict["user"] = user_id_counter
            pickle_save_ids(id_dict)

            with open("pickle_saves/students.pkl", 'wb') as students_file:
                all_students = {"name_id_dict": {}, "objects_dict": {}}

                all_students["objects_dict"][dax.user_id] = dax
                all_students["name_id_dict"][dax.username] = dax.user_id

                all_students["objects_dict"][greg.user_id] = greg
                all_students["name_id_dict"][greg.username] = greg.user_id

                pickle.dump(all_students, students_file)

            with open("pickle_saves/admins.pkl", 'wb') as admins_file:
                all_admins = {"name_id_dict": {}, "objects_dict": {}}

                all_admins["objects_dict"][daxxra.user_id] = daxxra
                all_admins["name_id_dict"][daxxra.username] = daxxra.user_id

                all_admins["objects_dict"][the_gregouze.user_id] = the_gregouze
                all_admins["name_id_dict"][the_gregouze.username] = the_gregouze.user_id
                pickle.dump(admins, admins_file)

            with open("pickle_saves/files.pkl", 'wb') as files_file:
                files = {"name_id_dict": {}, "objects_dict": {}}
                pickle.dump(files, files_file)
            with open("pickle_saves/courses.pkl", 'wb') as courses_file:
                courses = {"name_id_dict": {}, "objects_dict": {}}
                pickle.dump(courses, courses_file)

    @staticmethod
    def do_new(line):
        """
        new [OPTION=student, admin] [USERNAME] [FULLNAME]
        new [OPTION=course] [NAME] [TEACHER]...

        Methode permettant de creer une nouvelle instance d'une classe. La classe en question est specifiee par l'option

        PRE :   - option est de type str et vaut "student" ou "admin" :
                        * username est de type str et correspond au nom d'utilisateur du futur utilisateur
                        * fullname est de type str et correspond au nom complet du futur utilisateur
                        * il sera demande a l'utilisateur d'entrer deux fois un meme mot de passe de type str
                            avant creation de l'instance
                - option est de type str et vaut "course" :
                        * teacher est de type str et correspond a la liste des noms des professeurs separes par des
                            underscores
        POST : cree l'instance de la classe specifie ssi elle n'existe pas deja
            si option correspond a un utilisateur, le mot de passe doit etre identique les deux fois
        RAISES :    - PasswordNotEqualException si les deux mots de passe entre ne correspondent pas
                    - ObjectAlreadyExistantException si le nom de l'objet existe deja

        :param line: str
            La ligne d'arguments introduite a la suite de l'appel de la fonction do_mv dans l'interface
                en ligne de commande cree par le module cmd
        """

        all_students = pickle_get_students()
        all_admins = pickle_get_admins()
        all_courses = pickle_get_courses()
        if (("student" in line) ^ ("admin" in line)) and not ("course" in line):
            try:
                user_name = line.split()[1]
                fullname_list = line.split()[2:]
                fullname = ""
                for i in fullname_list:
                    fullname += i + " "
                fullname = fullname[:-1]
                if "student" in line:
                    pwd1 = getpass.getpass("Veuillez creer un mot de passe :")
                    pwd2 = getpass.getpass("Veuillez confirmer le mot de passe entre:")
                    if pwd1 == pwd2:
                        id_dict = pickle_get_ids()
                        student_instance = Student(user_name, fullname, pwd1, id_dict["user"])
                        id_dict["user"] += 1
                        pickle_save_ids(id_dict)
                        if user_name in all_students["name_id_dict"]:
                            raise ObjectAlreadyExistantException
                        all_students["objects_dict"][student_instance.user_id] = student_instance
                        all_students["name_id_dict"][user_name] = student_instance.user_id
                    else:
                        raise PasswordNotEqualException
                if "admin" in line:
                    pwd1 = getpass.getpass("Veuillez creer un mot de passe :")
                    pwd2 = getpass.getpass("Veuillez confirmer le mot de passe entre:")
                    if pwd1 == pwd2:
                        id_dict = pickle_get_ids()
                        admin_instance = Admin(user_name, fullname, pwd1, id_dict["user"])
                        id_dict["user"] += 1
                        pickle_save_ids(id_dict)
                        if user_name in all_admins["name_id_dict"]:
                            raise ObjectAlreadyExistantException
                        all_admins["objects_dict"][admin_instance.user_id] = admin_instance
                        all_admins["name_id_dict"][user_name] = admin_instance.user_id
                    else:
                        raise PasswordNotEqualException
            except ObjectAlreadyExistantException:
                print("Un utilisateur du meme nom existe deja\nVeuillez reessayer avec un autre username :\n")
            except PasswordNotEqualException:
                print("Les mots de passe entres ne correspondent pas\nVeuillez reessayer :\n")
            except NumberOfArgumentsException:
                print("La commande mv demande deux arguments : [CURRENT_PATHNAME] [NEW_PATHNAME]\n")
            except Exception as e:
                print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
            else:
                pickle_save(all_students=all_students, all_admins=all_admins)
                print("L'utilisateur a ete correctement cree\n")
        elif "course" in line and not [("student" in line) or ("admin" in line)]:
            try:
                if len(line.split()) == 3:
                    name, teachers = [s for s in line.split()[1:]]
                    teachers = teachers.split("_")
                    id_dict = pickle_get_ids()
                    course_instance = Course(name, teachers, id_dict["course"])
                    id_dict += 1
                    pickle_save_ids(id_dict)
                    if name in all_courses["name_id_dict"]:
                        raise ObjectAlreadyExistantException
                    all_courses["objects_dict"][course_instance.course_id] = course_instance
                    all_courses["name_id_dict"][name] = course_instance.course_id
                else:
                    raise NumberOfArgumentsException
            except ObjectAlreadyExistantException:
                print("Un cours avec le meme intitule existe deja\nVeuillez reessayer avec un autre nom :\n")
            except NumberOfArgumentsException:
                print("La commande mv demande deux arguments : [CURRENT_PATHNAME] [NEW_PATHNAME]\n")
            except Exception as e:
                print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
            else:
                pickle_save(courses=all_courses)
                print("Le cours a ete correctement cree\n")
        else:
            str1 = "Les arguments entres sont incorrects : [OPTION] a trois valeurs possibles :"
            str2 = "\nstudent\nadmin\ncourse\nVeuillez reessayer :\n"
            print(str1, str2)

    @staticmethod
    def do_del(line):
        """
        del [OPTION=student, admin] [USERNAME]
        del [OPTION=course] [NAME]

        Methode permettant de creer une nouvelle instance d'une classe. La classe en question est specifiee par l'option

        PRE :   - option est de type str et vaut "student" ou "admin" :
                        * username est de type str et correspond au nom d'utilisateur du futur utilisateur
                        * fullname est de type str et correspond au nom complet du futur utilisateur
                - option est de type str et vaut "course" :
                        * teacher est de type str et correspond a la liste des noms des professeurs separes par des
                            underscores
        POST : cree l'instance de la classe specifie ssi elle n'existe pas deja
                - si l'instance est un utilisateur, toutes les instances des fichiers qu'il possede sont supprimees
                    et il est desinscrit de tous ses cours
                - si l'instance est un cours, toutes les instances des fichiers qui lui sont associes voient leur
                    attribut prive course_id devenir None et tous les etudiants inscrits a ce cours en sont desinscrits

        :param line: str
            La ligne d'arguments introduite a la suite de l'appel de la fonction do_mv dans l'interface
                en ligne de commande cree par le module cmd
        """
        all_students = pickle_get_students()
        all_courses = pickle_get_courses()
        all_files = pickle_get_files()
        all_admins = pickle_get_admins()
        if (("student" in line) ^ ("admin" in line)) and not ("course" in line):
            try:
                user_name = line.split()[1]
                if user_name in ["dax", "greg", "daxxra", "TheGregouze", username]:
                    raise CannotDeleteUserException
                if "student" in line:
                    if user_name not in all_students["name_id_dict"]:
                        raise UnknownObjectNameException
                    student_instance_id = all_students["name_id_dict"][user_name]
                    student_instance = all_students["objects_dict"][student_instance_id]
                    file_ids = student_instance.files
                    course_ids = student_instance.courses
                    if file_ids:
                        for i in file_ids:
                            course_id = all_files["objects_dict"][i].course_id
                            if course_id:
                                course_instance = all_courses["objects_dict"][course_id]
                                course_instance.remove_file(i)
                                all_courses["name_id_dict"][course_id] = course_instance
                            file_pathname = all_files["objects_dict"][i].pathname
                            del all_files["objects_dict"][i]
                            del all_files["name_id_dict"][file_pathname]
                    if course_ids:
                        for i in course_ids:
                            course_instance = all_courses["objects_dict"][i]
                            course_instance.remove_student(student_instance_id)
                            all_courses["name_id_dict"][i] = course_instance
                    del all_students["objects_dict"][student_instance_id]
                    del all_students["name_id_dict"][user_name]
                if "admin" in line:
                    if user_name not in all_admins["name_id_dict"]:
                        raise UnknownObjectNameException
                    admin_instance_id = all_admins["name_id_dict"][user_name]
                    del all_admins["objects_dict"][admin_instance_id]
                    del all_admins["name_id_dict"][user_name]
            except UnknownObjectNameException:
                print("Impossible de supprimmer l'utilisateur : le username est inconnu\n")
            except CannotDeleteUserException:
                print("Impossible de supprimmer l'utilisateur : il s'agit soit d'un root_user, soit de l'utilisateur "
                      "connecte\n")
            except Exception as e:
                print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
            else:
                pickle_save(all_students=all_students, all_admins=all_admins, files=all_files, courses=all_courses)
                print("L'utilisateur a ete correctement suprimme\n")
        elif "course" in line and not [("student" in line) or ("admin" in line)]:
            try:
                name = line.split()[1]
                if name not in all_courses["name_id_dict"]:
                    raise UnknownObjectNameException
                course_instance_id = all_courses["name_id_dict"][name]
                course_instance = all_courses["objects_dict"][course_instance_id]
                file_ids = course_instance.files
                student_ids = course_instance.students
                if file_ids:
                    for i in file_ids:
                        file_instance = all_files["objects_dict"][i]
                        file_instance.course_id = None
                        all_files["name_id_dict"][i] = file_instance
                if student_ids:
                    for i in student_ids:
                        student_instance = all_students["objects_dict"][i]
                        student_instance.remove_course(course_instance_id)
                        all_students["name_id_dict"][i] = student_instance
                del all_courses["objects_dict"][course_instance_id]
                del all_courses["name_id_dict"][name]
            except UnknownObjectNameException:
                print("Impossible de supprimmer le cours : l'intitule est inconnu\n")
            except Exception as e:
                print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
            else:
                pickle_save(all_students=all_students, files=all_files, courses=all_courses)
                print("Le cours a ete correctement supprimme\n")
        else:
            str1 = "Les arguments entres sont incorrects : [OPTION] a trois valeurs possibles :"
            str2 = "\nstudent\nadmin\ncourse\nVeuillez reessayer :\n"
            print(str1, str2)

    @staticmethod
    def do_list_users(usertype):
        """
        list_users [USERTYPE=all, students, admins]

        Methode permettant de lister les utilisateurs connus du programme

        PRE : usertype est de type str et peut correspondre a trois valeurs differentes (all, students, admins)
        POST : liste en console la liste des utilisateurs demandes
            ssi usertype correspond a une des trois valeurs admises

        :param usertype: str
            correspond au type d'utilisateur a lister : all, students, admins
        """

        all_students = pickle_get_students()
        all_admins = pickle_get_admins()
        if usertype == "all" or usertype == "students":
            print("Utilisateurs etudiants :")
            key_list = all_students["objects_dict"].keys()
            for i in key_list:
                user_string1 = f"id={all_students['objects_dict'][i].user_id}  "
                user_string2 = f"{all_students['objects_dict'][i].username} "
                user_string3 = f"({all_students['objects_dict'][i].fullname})"
                print(user_string1, user_string2, user_string3)
            print("\n")
        if usertype == "all" or usertype == "admins":
            print("Utilisateurs administrateurs :")
            key_list = all_admins["objects_dict"].keys()
            for i in key_list:
                user_string1 = f"id={all_admins['objects_dict'][i].user_id}  "
                user_string2 = f"{all_admins['objects_dict'][i].username} "
                user_string3 = f"({all_admins['objects_dict'][i].fullname})"
                print(user_string1, user_string2, user_string3)
            print("\n")
        if usertype != "all" and usertype != "students" and usertype != "admins":
            print("L'argument [USERTYPE] a trois valeurs autorisees :\nall\nstudents\nadmins\n")


class Cli(cmd.Cmd):
    """Cette classe permet de creer une interface en ligne de commande personalisee a l'aide du module cmd"""
    intro = "Bienvenue dans le shell CLI du projet python 2TL1_09 :\n\nIntroduire help ou ? pour lister les " \
            "commandes disponibles\n\n"

    @staticmethod
    def do_del(pathname):
        """
        del [PATHNAME]

        Methode permettant de supprimer un fichier a la fois des donnes de fonctionnement du programme et
            de la memoire locale ou distante

        PRE : pathname est de type str et correspond au pathname du fichier a supprimer
        POST :  - le fichier est suprimme du programme et de la memoire locale ou distante ssi pathname correspond
                    au pathname d'un fichier existant et connu du programme et ssi l'utilisateur connecte possede
                    ce fichier
                - le file_id du fichier est retiré des listes files des instances des classes Student et Course
                    appropriees ssi elles existent

        :param pathname: str
            Correspond au pathname du fichier a supprimer sur la memoire locale ou distante
        """
        all_students = pickle_get_students()
        all_files = pickle_get_files()
        all_courses = pickle_get_courses()
        try:
            file_instance = if_proprietor_get_file(pathname)
            del all_files["name_id_dict"][pathname]
            del all_files["objects_dict"][file_instance.file_id]

            if file_instance.course_id is not None:
                course_instance = all_courses["objects_dict"][file_instance.course_id]
                course_instance.remove_file(file_instance.file_id)
                all_courses["objects_dict"][course_instance.course_id] = course_instance

            user_instance.remove_file(file_instance.file_id)
            all_students["objects_dict"][user_id] = user_instance
        except FileNotFoundException:
            print(f"Le fichier {pathname} n'existe pas\n")
        except FileNotOwnedException:
            print(f"Le fichier {pathname} ne vous appartient pas\n")
        except Exception as e:
            print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
        else:
            if os.path.isfile(pathname):
                os.remove(pathname)
                print("Le fichier n'existe plus sur le disque dur")
            else:
                print("Le fichier n'existe pas sur le disque dur")
            print("Le fichier a correctement ete supprime du programme\n")
            pickle_save(all_students, files=all_files, courses=all_courses)

    @staticmethod
    def do_mv(line):
        """
        mv [CURRENT_PATHNAME] [NEW_PATHNAME]

        Methode permettant de deplacer et/ou de renommer un fichier sur la memoire locale ou distante
            et de mettre a jour les donnees de fonctionnoment du programme en consequence

        PRE : line est de type str et correspond a deux sequences de caracteres separees par un espace
                    - la premiere sequence (current_pathname) correspond au pathname
                        actuel du fichier a deplacer/renommer
                    - la deuxieme sequence (new_pathname) correspond au pathname
                        desire pour le fichier a deplacer/renommer
        POST : le fichier est deplace/renomme sur la memoire locale ou distante ssi :
                    - current_pathname correspond au pathname d'un fichier existant et connu du programme
                    - le chemin d'acces specifie par pathname correspond a un chemin existant sur la memoire
                        locale ou distante
        RAISES : NumberOfArgumentsException si l'utilisateur n'entre pas exactement deux arguments apres l'appel
            de la commande

        :param line: str
            La ligne d'arguments introduite a la suite de l'appel de la fonction do_mv dans l'interface
                en ligne de commande cree par le module cmd
        """

        all_files = pickle_get_files()
        current_pathname = ""
        try:
            if len(line.split()) == 2:
                current_pathname, new_pathname = [s for s in line.split()]
            else:
                raise NumberOfArgumentsException
            file_instance = if_proprietor_get_file(current_pathname)
            file_instance.pathname = new_pathname
            if os.path.isfile(current_pathname):
                os.rename(current_pathname, new_pathname)
            else:
                raise FileNotFoundException
            all_files["objects_dict"][file_instance.file_id] = file_instance
            all_files["name_id_dict"][file_instance.pathname] = file_instance.file_id
            del all_files["name_id_dict"][current_pathname]
        except NumberOfArgumentsException:
            print("La commande mv demande deux arguments : [CURRENT_PATHNAME] [NEW_PATHNAME]\n")
        except FileNotFoundException:
            print(f"Le fichier {current_pathname} n'existe pas\n")
        except FileNotOwnedException:
            print(f"Le fichier {current_pathname} ne vous appartient pas\n")
        except Exception as e:
            print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
        else:
            print(f"Le fichier {current_pathname} a ete déplacé vers {new_pathname}\n")
            pickle_save(files=all_files)

    @staticmethod
    def do_sort():
        pass

    @staticmethod
    def do_open(pathname):
        pass

    @staticmethod
    def do_touch(line):
        """
        touch [PATHNAME] [OPTION]...

        OPTIONS :
                --course [COURSENAME]
                    permet d'assigner le fichier a un cours
                --tag [TAG]...
                    permet d'assigner un ou plusieurs tags au fichier
                --script
                    permet de signifier que le contenu du fichier est un script


        Methode permettant de creer un fichier vide a la fois pour le programme et sur la memoire locale ou distante

        PRE :   - pathname est de type str et correspond au pathname du fichier a creer
                - (--course) coursename est de type str et correspond au nom du cours auquel on veut associer le fichier
                - (--tag) chaque tag est de type str
        POST : le fichier est cree dans le programme et sur la memoire locale ou distante ssi pathname ne correspond
            au pathname d'aucun fichier existant sur la memoire locale ou distante ou a un fichier connu du programme
            si une option est specifiee :
                --course : l'identifiant unique du cours precise est inscrit dans l'attribut prive course du fichier et
                        l'identifiant unique du fichier est inscrit dans la liste files du cours specifie
                        Si cette option n'est pas specifie, la valeur None est enregistree a la place
                --tag : chaque tag specifie est inscrit comme un element de la liste tags du fichier
                        Si cette option n'est pas specifiee, la valeur None est enregistree a la place
                --script : la valeur de l'attribut prive script du fichier est passe a False
                        Si cette option n'est pas specifiee, la valeur False est enregistree a la place

        :param line: str
            La ligne d'arguments introduite a la suite de l'appel de la fonction do_touch dans l'interface
                en ligne de commande cree par le module cmd
        """

        tag_index = ["--tag " in line, "--tag "]
        course_index = ["--course " in line, "--course "]
        script_index = ["--script " in line, "--script "]
        options = [tag_index, course_index, script_index]
        specified_options_dict = specified_options(line, options)

        try:
            pathname = line.split(" --")[0]
        except AttributeError:
            pathname = line
        except Exception as e:
            print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
            return

        tags = None
        script = False
        course_id = None

        if "--tag " in specified_options_dict:
            tags = list(specified_options_dict["--tag "].split())
        if "--script " in specified_options_dict:
            script = specified_options_dict["--script "]
        if "--course " in specified_options_dict:
            course_name = specified_options_dict["--course "]
            courses = pickle_get_courses()
            course_id = courses["name_id_dict "][course_name]

        all_students = pickle_get_students()
        all_courses = pickle_get_courses()
        all_files = pickle_get_files()
        try:
            id_dict = pickle_get_ids()
            file_instance = File(user_id, pathname, course_id, id_dict["file"], script, tags)
            id_dict["file"] += 1
            pickle_save_ids(id_dict)
            if file_instance.file_id not in all_files["objects_dict"]:
                all_files["objects_dict"][file_instance.file_id] = file_instance
                all_files["name_id_dict"][file_instance.pathname] = file_instance.file_id
            else:
                raise ObjectAlreadyExistantException

            user_instance.add_file(file_instance.file_id)
            all_students["objects_dict"][user_id] = user_instance
            if course_id is not None:
                course_instance = all_courses["objects_dict"][course_id]
                course_instance.add_file(file_instance.file_id)
                all_courses["objects_dict"][course_id] = course_instance
        except ObjectAlreadyExistantException:
            print(f"Le fichier {pathname} est deja connu du programme:\n")
        except AlreadyInListException:
            print(f"Le fichier {pathname} existe deja:\n")
        except Exception as e:
            print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
        else:
            pickle_save(all_students=all_students, files=all_files, courses=all_courses)
            print(f"Le fichier {file_instance.pathname} est maintenant connu du programme\n")

    @staticmethod
    def do_cat(pathname):
        """
        cat [PATHNAME]

        Methode permettant d'afficher en console le contenu d'un fichier

        PRE : pathname est de type str et correspond au pathname d'un fichier existant et connu du programme
        POST : le contenu du fichier est affiche en console ssi pathname correspond au pathname d'un fichier
            existant sur la memoire locale ou distante et connu du programme

        :param pathname: str
            Correspond au pathname sur la memoire locale ou distante du fichier dont on desire afficher
                le contenu en console
        """

        try:
            file_instance = if_proprietor_get_file(pathname)
            file_instance.read_file()
        except FileExistsError:
            print(f"Le fichier {pathname} n'existe pas")
        except IOError:
            print('Erreur IO.')
        except FileNotFoundException:
            print(f"Le fichier {pathname} n'existe pas\n")
        except FileNotOwnedException:
            print(f"Le fichier {pathname} ne vous appartient pas\n")
        except Exception as e:
            print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")

    @staticmethod
    def do_write(line):
        """
        write [PATHNAME] [CONTENT]

        Methode permettant d'ecrire du contenu dans un fichier

        PRE : line est de type str et correspond a deux sequences de caracteres separees par un espace
                    - la premiere sequence (pathname) correspond au pathname
                        d'un fichier existant et connu du programme
                    - la deuxieme sequence (content) correspond au contenu
                        que l'on desire ecrire sur le fichier
        POST : content est ecrit sur le fichier ssi pathname correspond au pathname d'un fichier existant sur la
            memoire locale ou distante et connu du programme

        :param line: str
            La ligne d'arguments introduite a la suite de l'appel de la fonction do_write dans l'interface
                en ligne de commande cree par le module cmd
        """

        pathname = line.split()[0]
        content = line.replace(pathname + " ", "")
        try:
            file_instance = if_proprietor_get_file(pathname)
            file_instance.write_file(content)
        except FileExistsError:
            print(f"Le fichier {pathname} n'existe pas")
        except IOError:
            print('Erreur IO.')
        except FileNotFoundException:
            print(f"Le fichier {pathname} n'existe pas\n")
        except FileNotOwnedException:
            print(f"Le fichier {pathname} ne vous appartient pas\n")
        except Exception as e:
            print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
        else:
            print(f"Le contenu a ete correctement ecrit sur {pathname}\n")

    @staticmethod
    def do_append(line):
        """
        append [PATHNAME] [CONTENT]

        Methode permettant d'ecrire du contenu a la fin d'un fichier

        PRE : line est de type str et correspond a deux sequences de caracteres separees par un espace
                    - la premiere sequence (pathname) correspond au pathname
                        d'un fichier existant et connu du programme
                    - la deuxieme sequence (content) correspond au contenu
                        que l'on desire ecrire a la fin du fichier
        POST : content est ecrit dans le fichier ssi pathname correspond au pathname d'un fichier existant sur la
            memoire locale ou distante et connu du programme

        :param line: str
            La ligne d'arguments introduite a la suite de l'appel de la fonction do_write dans l'interface
                en ligne de commande cree par le module cmd
        """

        pathname = line.split()[0]
        content = line.replace(pathname + " ", "")
        try:
            file_instance = if_proprietor_get_file(pathname)
            file_instance.append_file(content)
        except FileExistsError:
            print(f"Le fichier {pathname} n'existe pas")
        except IOError:
            print('Erreur IO.')
        except FileNotFoundException:
            print(f"Le fichier {pathname} n'existe pas\n")
        except FileNotOwnedException:
            print(f"Le fichier {pathname} ne vous appartient pas\n")
        except Exception as e:
            print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
        else:
            print(f"Le contenu a ete correctement ecrit sur {pathname}\n")

    @staticmethod
    def do_vi(pathname):
        """
        vi [PATHNAME]

        Methode permettant d'ouvrir un fichier dans l'editeur de texte vi

        PRE : pathname est de type str et correspond au pathname d'un fichier existant et connu du programme
        POST : le fichier est ouvert dans vi en console ssi pathname correspond au pathname d'un fichier
            existant sur la memoire locale ou distante et connu du programme

        :param pathname: str
            Correspond au pathname sur la memoire locale ou distante du fichier que l'on desire editer avec vi
        """

        try:
            editor = os.getenv('EDITOR', 'vi')
            subprocess.call(f"{editor} {pathname}", shell=True)
        except FileExistsError:
            print(f"Le fichier {pathname} n'existe pas")
        except IOError:
            print('Erreur IO.')
        except Exception as e:
            print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")

    @staticmethod
    def do_my_files(line):
        """
        my_files

        PRE : line est une chaine de caractere vide
        RAISES : CommandHasNoArgumentsException si line n'est pas une chaine de caractere vide

        Methode permettant de lister les fichiers appartenant a l'utilisateur connecte

        :param line: str
            chaine vide car la fonction reset ne demande pas de parametres
        """

        try:
            if line != "":
                raise CommandHasNoArgumentsException
        except CommandHasNoArgumentsException:
            print("La fonction n'accepte aucun argument\nVeuillez reesayer :\n")
        else:
            all_files = pickle_get_files()
            files = user_instance.files
            if files:
                for i in files:
                    print(f"id={i}    {all_files['objects_dict'][i].pathname}")
            print("\n")

    @staticmethod
    def do_courses(line):
        """
        courses

        PRE : line est une chaine de caractere vide
        RAISES : CommandHasNoArgumentsException si line n'est pas une chaine de caractere vide

        Methode permettant de lister les cours connus du programme

        :param line: str
            chaine vide car la fonction reset ne demande pas de parametres
        """

        try:
            if line != "":
                raise CommandHasNoArgumentsException
        except CommandHasNoArgumentsException:
            print("La fonction n'accepte aucun argument\nVeuillez reesayer :\n")
        else:
            all_courses = pickle_get_courses()
            course_keys = all_courses["name_id_dict"].keys()
            if course_keys:
                for i in course_keys:
                    print(f"id={all_courses['name_id_dict'][i]}    {i}")
            print("\n")

    @staticmethod
    def do_my_courses(line):
        """
        my_courses

        PRE : line est une chaine de caractere vide
        RAISES : CommandHasNoArgumentsException si line n'est pas une chaine de caractere vide

        Methode permettant de lister les cours auxquels l'utilisateur connecte est inscrit

        :param line: str
            chaine vide car la fonction reset ne demande pas de parametres
        """

        try:
            if line != "":
                raise CommandHasNoArgumentsException
        except CommandHasNoArgumentsException:
            print("La fonction n'accepte aucun argument\nVeuillez reesayer :\n")
        else:
            all_courses = pickle_get_courses()
            courses = user_instance.courses
            if courses:
                for i in courses:
                    print(
                        f"id={i}    {all_courses['objects_dict'][i].name}    {all_courses['objects_dict'][i].teachers}")
            print("\n")

    @staticmethod
    def do_sub(course_name):
        """
        sub [COURSE_NAME]

        PRE : course_name est de type str et correspond au nom d'un cours connu du programme
        POST : inscrit l'utilisateur connecte au cours ssi le cours est connu du programme
        RAISES : UnknownObjectNameException si le cours n'existe pas

        :param course_name: str
            Le nom du cours auquel l'utilisateur connecte desire s'inscrire
        """

        all_courses = pickle_get_courses()
        all_students = pickle_get_students()
        course_instance_id = all_courses["name_id_dict"][course_name]
        course_instance = all_courses["objects_dict"][course_instance_id]
        try:
            course_instance.add_student(user_id)
            user_instance.add_course(course_instance_id)
        except AlreadyInListException:
            print("Vous etes deja inscrits a ce cours\n")
        except Exception as e:
            print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
        else:
            pickle_save(all_students=all_students, courses=all_courses)
            print(f"Vous etes maintenant inscrit au cours {course_name}")

    @staticmethod
    def do_unsub(course_name):
        """
        unsub [COURSE_NAME]

        PRE : course_name est de type str et correspond au nom d'un cours connu du programme
        POST : desinscrit l'utilisateur connecte du cours ssi le cours est connu du programme
        RAISES : UnknownObjectNameException si le cours n'existe pas

        :param course_name: str
            Le nom du cours auquel l'utilisateur connecte desire s'inscrire
        """

        all_courses = pickle_get_courses()
        all_students = pickle_get_students()
        course_instance_id = all_courses["name_id_dict"][course_name]
        course_instance = all_courses["objects_dict"][course_instance_id]
        try:
            course_instance.remove_student(user_id)
            user_instance.remove_course(course_instance_id)
        except NotInListException:
            print("Vous n'etes pas inscrits a ce cours\n")
        except Exception as e:
            print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
        else:
            pickle_save(all_students=all_students, courses=all_courses)
            print(f"Vous etes maintenant desinscrit du cours {course_name}")

    @staticmethod
    def do_specify_course(line):
        """
        specify_course [PATHNAME] [COURSE_NAME]

        PRE : line est de type str et correspond a deux sequences de caracteres separees par un espace
                    - la premiere sequence (pathname) correspond au pathname
                        d'un fichier existant et connu du programme
                    - la deuxieme sequence (course_name) correspond au nom d'un cours existant
        POST : specifie que le fichier traite du cours precise ssi le fichier et le cours existent
        RAISES : UnknownObjectNameException si le cours et/ou le fichier n'existe pas

        :param line: str
            La ligne d'arguments introduite a la suite de l'appel de la fonction do_write dans l'interface
                en ligne de commande cree par le module cmd
        """

        all_files = pickle_get_files()
        all_courses = pickle_get_courses()
        pathname = line.split()[0]
        course_name = line.split()[1]
        try:
            if not (pathname in all_files["name_id_dict"] and course_name in all_courses["name_id_dict"]):
                raise UnknownObjectNameException
            file_instance_id = all_files["name_id_dict"][pathname]
            file_instance = all_files["objects_dict"][file_instance_id]
            course_instance_id = all_files["name_id_dict"][course_name]
            course_instance = all_files["objects_dict"][course_instance_id]

            file_instance.course_id = course_instance_id
            course_instance.add_file(file_instance_id)
        except UnknownObjectNameException:
            print("Le fichier et/ou le cours precise n'existe pas\nVeuillez reessayer :\n")
        except AlreadyInListException:
            print(f"Le fichier {pathname} est deja associe au cours {course_name}\n")
        except Exception as e:
            print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
        else:
            pickle_save(files=all_files, courses=all_courses)
            print(f"Le fichier {pathname} est maintenant associe au cours {course_name}")

    @staticmethod
    def do_unspecify_course(pathname):
        """
        unspecify_course [PATHNAME]

        PRE : pathname est de type str et correspond a un fichier existant et connu du programme
        POST : supprimme les liens entre le fichier et le cours auquel il est associe
        RAISES : UnknownObjectNameException si le fichier n'existe pas

        :param pathname: str
            Le chemin d'acces vers le fichier sur la memoire locale ou distante
        """

        all_files = pickle_get_files()
        all_courses = pickle_get_courses()
        try:
            if pathname not in all_files["name_id_dict"]:
                raise UnknownObjectNameException
            file_instance_id = all_files["name_id_dict"][pathname]
            file_instance = all_files["objects_dict"][file_instance_id]
            course_instance_id = file_instance.course_id
            if course_instance_id not in all_courses["objects_dict"]:
                raise UnknownObjectNameException
            course_instance = all_files["objects_dict"][course_instance_id]

            file_instance.course_id = None
            course_instance.remove_file(file_instance_id)
        except UnknownObjectNameException:
            print("Le fichier et/ou le cours precise n'existe pas\nVeuillez reessayer :\n")
        except NotInListException:
            print(f"Le fichier {pathname} n'est associe associe a aucun cours\n")
        except Exception as e:
            print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
        else:
            pickle_save(files=all_files, courses=all_courses)
            print(f"Le fichier {pathname} n'est plus associe a aucun cours")


def specified_options(line, options):
    """Methode permettant d'isoler les options d'une ligne d'argument du module cmd

    PRE :   - line est de type str
            - options est une liste comportant deux elements :
                    * le premier annonce si l'option se trouve dans line et est de type bool
                    * le deuxieme est la sequence de caractere marquant l'option dans line

    :param line: str
        La ligne d'arguments introduite a la suite de l'appel de la fonction do_write dans l'interface
            en ligne de commande cree par le module cmd
    :param options: list
        liste des options possiblement presente dans line
    :return specified_options_dict: dict
        dictionnaire {option : argument}
    """

    specified_options_dict = {}
    for i in options:
        if i[0]:
            try:
                found = re.search(i[1] + "(.+?)" + " --", line).group(1)
                specified_options_dict[i[1]] = found
            except AttributeError:
                found = line.split(i[1])[1]
                specified_options_dict[i[1]] = found
    return specified_options_dict


def if_proprietor_get_file(pathname):
    """Methode renvoyant l'instance de la classe File associee a un fichier

    PRE : pathname est de type str
    POST : retourne l'instance de la classe File associee au fichier ssi le fichier
        existe et qu'il appartient a l'utilisateur connecte
    RAISES :    - FileNotFoundException si le fichier n'existe pas sur la memoire locale ou distante
                - FileNotOwnedException si le fichier existe mais n'apartient pas a l'utilisateur connecte

    :param pathname: str
        Le chemin d'acces vers le fichier sur la memoire locale ou distante
    :return: object
        L'instance de la classe File associee au fichier
    """

    files = pickle_get_files()
    if pathname in files["name_id_dict"]:
        file_id = files["name_id_dict"][pathname]
        file_instance = files["objects_dict"][file_id]
        if file_id in user_instance.files:
            return file_instance
        else:
            raise FileNotOwnedException
    else:
        raise FileNotFoundException


def pickle_save(all_students=None, all_admins=None, files=None, courses=None):
    """Methode statique permettant d'enregistrer les modifications sur les classes persistantes du programme
            Seules les classes specfiees dans les parametres sont sauvegardees
    """

    if all_students is not None:
        with open("pickle_saves/students.pkl", 'wb') as students_file:
            pickle.dump(all_students, students_file)
    if all_admins is not None:
        with open("pickle_saves/admins.pkl", 'wb') as admins_file:
            pickle.dump(all_admins, admins_file)
    if files is not None:
        with open("pickle_saves/files.pkl", 'wb') as files_file:
            pickle.dump(files, files_file)
    if courses is not None:
        with open("pickle_saves/courses.pkl", 'wb') as courses_file:
            pickle.dump(courses, courses_file)


def pickle_get_students():
    """Methode statique permettant de recuperer les instances persistantes de la classe Student

    :return students : dict
        dictionnaire contenant les instances persistantes de la classe Student
    """

    with open("pickle_saves/students.pkl", 'rb') as students_file:
        all_students = pickle.load(students_file)

    return all_students


def pickle_get_admins():
    """Methode statique permettant de recuperer les instances persistantes de la classe Admin

    :return admins : dict
        dictionnaire contenant les instances persistantes de la classe Admin
    """

    with open("pickle_saves/admins.pkl", 'rb') as admins_file:
        all_admins = pickle.load(admins_file)

    return all_admins


def pickle_get_files():
    """Methode statique permettant de recuperer les instances persistantes de la classe File

    :return files : dict
        dictionnaire contenant les instances persistantes de la classe File
    """

    with open("pickle_saves/files.pkl", 'rb') as files_file:
        files = pickle.load(files_file)

    return files


def pickle_get_courses():
    """Methode statique permettant de recuperer les instances persistantes de la classe Course

    :return courses : dict
        dictionnaire contenant les instances persistantes de la classe Course
    """

    with open("pickle_saves/courses.pkl", 'rb') as courses_file:
        courses = pickle.load(courses_file)

    return courses


def pickle_get_ids():
    """Methode statique permettant de recuperer les valeurs persistantes des identifiants uniques pour
        les classes utilisateurs, File et Course

        :return id_dict : dict
            dictionnaire contenant les valeurs persistantes des identifiants uniques pour
                les classes utilisateurs, File et Course
        """

    with open("pickle_saves/id_dict.pkl", 'rb') as ids_file:
        id_dict = pickle.load(ids_file)

    return id_dict


def pickle_save_ids(id_dict):
    """Methode statique permettant d'enregistrer les modifications sur les identifiants uniques des classes utilisateur
        File et Course
    """

    with open("pickle_saves/id_dict.pkl", 'wb') as ids_file:
        pickle.dump(id_dict, ids_file)


if __name__ == "__main__":
    username = input("Veuillez entrer votre nom d'utilisateur :")
    students = pickle_get_students()
    admins = pickle_get_admins()
    if username in students["name_id_dict"]:
        try:
            pwd = getpass.getpass("Veuillez entrer votre mot de passe :")
            user_id = students["name_id_dict"][username]
            user_instance = students["objects_dict"][user_id]
            user_instance.verify_pwd(pwd)
        except UnknownPasswordException:
            print("Le mot de passe est errone")
        else:
            Cli.prompt = f"({username}) >>"
            Cli().cmdloop()
    elif username in admins["name_id_dict"]:
        try:
            pwd = getpass.getpass("Veuillez entrer votre mot de passe :")
            user_id = admins["name_id_dict"][username]
            user_instance = admins["objects_dict"][user_id]
            user_instance.verify_pwd(pwd)
        except UnknownPasswordException:
            print("Le mot de passe est errone")
        else:
            AdminCli.prompt = f"({username}) ##"
            AdminCli().cmdloop()
    else:
        print("Le nom d'utilisateur n'existe pas")
