#!/usr/bin/env python3
import cmd
import getpass
import os
import pickle
import re

from classes.exceptions import FileNotFoundException, FileNotOwnedException, UnknownPasswordException, \
    AlreadyInListException
from classes.file import File


class Cli(cmd.Cmd):
    """Cette classe permet de creer une interface en ligne de commande personalisee a l'aide du module cmd"""
    intro = "Bienvenue dans le shell CLI du projet python 2TL1_09 :\n\nIntroduire help ou ? pour lister les " \
            "commandes disponibles\n\n"
    prompt = "(CLI) >>"

    @staticmethod
    def do_del(pathname):
        """
        del [PATHNAME]

        Methode permettant de supprimer un fichier a la fois des donnes de fonctionnement du programme et
            de la memoire locale ou distante

        PRE : pathname est de type str et correspond au pathname du fichier a supprimer
        POST :  - le fichier est suprimme du programme et de la memoire locale ou distante ssi pathname correspond
                    au pathname d'un fichier existant et connu du programme et ssi l'utilisateur connecte possede
                    ce fichier
                - le file_id du fichier est retiré des listes files des instances des classes Student et Course
                    appropriees ssi elles existent

        :param pathname: str
            Correspond au pathname du fichier a supprimer sur la memoire locale ou distante
        """

        try:
            file_instance = if_proprietor_get_file(pathname)
            files = pickle_get_files()
            del files["name_id_dict"][pathname]
            del files["objects_dict"][file_instance.file_id]

            courses = pickle_get_courses()
            if file_instance.course_id is not None:
                course_instance = courses["objects_dict"][file_instance.course_id]
                course_instance.remove_file(file_instance.file_id)
                courses["objects_dict"][course_instance.course_id] = course_instance

            students = pickle_get_students()
            user_instance.remove_file(file_instance.file_id)
            students["objects_dict"][user_id] = user_instance
        except FileNotFoundException:
            print(f"Le fichier {pathname} n'existe pas\n")
        except FileNotOwnedException:
            print(f"Le fichier {pathname} ne vous appartient pas\n")
        except Exception as e:
            print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
        else:
            if os.path.isfile(pathname):
                os.remove(pathname)
                print("Le fichier n'existe plus sur le disque dur")
            else:
                print("Le fichier n'existe pas sur le disque dur")
            print("Le fichier a correctement ete supprime du programme\n")
            pickle_save(students, files=files, courses=courses)

    @staticmethod
    def do_mv(line):
        """
        mv [CURRENT_PATHNAME] [NEW_PATHNAME]

        Methode permettant de deplacer et/ou de renommer un fichier sur la memoire locale ou distante
            et de mettre a jour les donnees de fonctionnoment du programme en consequence

        PRE : line est de type str et correspond a deux sequences de caracteres separees par un espace
                    - la premiere sequence (current_pathname) correspond au pathname
                        actuel du fichier a deplacer/renommer
                    - la deuxieme sequence (new_pathname) correspond au pathname
                        desire pour le fichier a deplacer/renommer
        POST : le fichier est deplace/renomme sur la memoire locale ou distante ssi :
                    - current_pathname correspond au pathname d'un fichier existant et connu du programme
                    - le chemin d'acces specifie par pathname correspond a un chemin existant sur la memoire
                        locale ou distante

        :param line: str
            La ligne d'arguments introduite a la suite de l'appel de la fonction do_mv dans l'interface
                en ligne de commande cree par le module cmd
        """

        current_pathname, new_pathname = [s for s in line.split()]
        try:
            file_instance = if_proprietor_get_file(current_pathname)
            file_instance.pathname = new_pathname
            if os.path.isfile(current_pathname):
                os.rename(current_pathname, new_pathname)
            else:
                raise FileNotFoundException
            files = pickle_get_files()
            files["objects_dict"][file_instance.file_id] = file_instance
            files["name_id_dict"][file_instance.pathname] = file_instance.file_id
            del files["name_id_dict"][current_pathname]
        except FileNotFoundException:
            print(f"Le fichier {current_pathname} n'existe pas\n")
        except FileNotOwnedException:
            print(f"Le fichier {current_pathname} ne vous appartient pas\n")
        except Exception as e:
            print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
        else:
            print(f"Le fichier {current_pathname} a ete déplacé vers {new_pathname}\n")
            pickle_save(files=files)

    @staticmethod
    def do_sort():
        pass

    @staticmethod
    def do_open(pathname):
        pass

    @staticmethod
    def do_touch(line):
        """
        touch [PATHNAME] [OPTION]...

        OPTIONS :
                --course [COURSENAME]
                    permet d'assigner le fichier a un cours
                --tag [TAG]...
                    permet d'assigner un ou plusieurs tags au fichier
                --script
                    permet de signifier que le contenu du fichier est un script


        Methode permettant de creer un fichier vide a la fois pour le programme et sur la memoire locale ou distante

        PRE :   - pathname est de type str et correspond au pathname du fichier a creer
                - (--course) coursename est de type str et correspond au nom du cours auquel on veut associer le fichier
                - (--tag) chaque tag est de type str
        POST : le fichier est cree dans le programme et sur la memoire locale ou distante ssi pathname ne correspond
            au pathname d'aucun fichier existant sur la memoire locale ou distante ou a un fichier connu du programme
            si une option est specifiee :
                --course : l'identifiant unique du cours precise est inscrit dans l'attribut prive course du fichier et
                        l'identifiant unique du fichier est inscrit dans la liste files du cours specifie
                        Si cette option n'est pas specifie, la valeur None est enregistree a la place
                --tag : chaque tag specifie est inscrit comme un element de la liste tags du fichier
                        Si cette option n'est pas specifiee, la valeur None est enregistree a la place
                --script : la valeur de l'attribut prive script du fichier est passe a False
                        Si cette option n'est pas specifiee, la valeur False est enregistree a la place

        :param line: str
            La ligne d'arguments introduite a la suite de l'appel de la fonction do_touch dans l'interface
                en ligne de commande cree par le module cmd
        """

        tag_index = ["--tag " in line, "--tag "]
        course_index = ["--course " in line, "--course "]
        script_index = ["--script " in line, "--script "]
        options = [tag_index, course_index, script_index]
        specified_options_dict = specified_options(line, options)

        try:
            pathname = line.split(" --")[0]
        except AttributeError:
            pathname = line
        except Exception as e:
            print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
            return

        tags = None
        script = False
        course_id = None

        if "--tag " in specified_options_dict:
            tags = list(specified_options_dict["--tag "].split())
        if "--script " in specified_options_dict:
            script = specified_options_dict["--script "]
        if "--course " in specified_options_dict:
            course_name = specified_options_dict["--course "]
            courses = pickle_get_courses()
            course_id = courses["name_id_dict "][course_name]

        try:
            files = pickle_get_files()
            file_instance = File(user_id, pathname, course_id, script, tags)
            files["objects_dict"][file_instance.file_id] = file_instance
            files["name_id_dict"][file_instance.pathname] = file_instance.file_id

            students = pickle_get_students()
            user_instance.add_file(file_instance.file_id)
            students["objects_dict"][user_id] = user_instance

            courses = pickle_get_courses()

            if course_id is not None:
                course_instance = courses["objects_dict"][course_id]
                course_instance.add_file(file_instance.file_id)
                courses["object_dict"][course_id] = course_instance
        except AlreadyInListException:
            print(f"Le fichier {file_instance.pathname} existe deja::\n")
        except Exception as e:
            print(f"Une erreur est survenue : {e}\nVeuillez reessayer\n")
        else:
            with open("pickle_saves/students.pkl", 'wb') as students_file:
                pickle.dump(students, students_file)
            with open("pickle_saves/files.pkl", 'wb') as files_file:
                pickle.dump(files, files_file)
            with open("pickle_saves/courses.pkl", 'wb') as courses_file:
                pickle.dump(courses, courses_file)
            print(f"Le fichier {file_instance.pathname} est maintenant connu du programme\n")

    @staticmethod
    def do_cat(pathname):
        """
        cat [PATHNAME]

        Methode permettant d'afficher en console le contenu d'un fichier

        PRE : pathname est de type str et correspond au pathname d'un fichier existant et connu du programme
        POST : le contenu du fichier est affiche en console ssi pathname correspond au pathname d'un fichier
            existant sur la memoire locale ou distante et connu du programme

        :param pathname: str
            Correspond au pathname sur la memoire locale ou distante du fichier dont on desire afficher
                le contenu en console
        """

        pass

    @staticmethod
    def do_write(line):
        """
        write [PATHNAME] [CONTENT]

        Methode permettant d'ecrire du contenu dans un fichier

        PRE : line est de type str et correspond a deux sequences de caracteres separees par un espace
                    - la premiere sequence (pathname) correspond au pathname
                        d'un fichier existant et connu du programme
                    - la deuxieme sequence (content) correspond au contenu
                        que l'on desire ecrire sur le fichier
        POST : content est ecrit sur le fichier ssi pathname correspond au pathname d'un fichier existant sur la
            memoire locale ou distante et connu du programme

        :param line: str
            La ligne d'arguments introduite a la suite de l'appel de la fonction do_write dans l'interface
                en ligne de commande cree par le module cmd
        """

        pass

    @staticmethod
    def do_append(line):
        """
        append [PATHNAME] [CONTENT]

        Methode permettant d'ecrire du contenu a la fin d'un fichier

        PRE : line est de type str et correspond a deux sequences de caracteres separees par un espace
                    - la premiere sequence (pathname) correspond au pathname
                        d'un fichier existant et connu du programme
                    - la deuxieme sequence (content) correspond au contenu
                        que l'on desire ecrire a la fin du fichier
        POST : content est ecrit dans le fichier ssi pathname correspond au pathname d'un fichier existant sur la
            memoire locale ou distante et connu du programme

        :param line: str
            La ligne d'arguments introduite a la suite de l'appel de la fonction do_write dans l'interface
                en ligne de commande cree par le module cmd
        """

        pass


def specified_options(line, options):
    """Methode permettant d'isoler les options d'une ligne d'argument du module cmd

    PRE :   - line est de type str
            - options est une liste comportant deux elements :
                    * le premier annonce si l'option se trouve dans line et est de type bool
                    * le deuxieme est la sequence de caractere marquant l'option dans line

    :param line: str
        La ligne d'arguments introduite a la suite de l'appel de la fonction do_write dans l'interface
            en ligne de commande cree par le module cmd
    :param options: list
        liste des options possiblement presente dans line
    :return specified_options_dict: dict
        dictionnaire {option : argument}
    """

    specified_options_dict = {}
    for i in options:
        if i[0]:
            try:
                found = re.search(i[1] + "(.+?)" + " --", line).group(1)
                specified_options_dict[i[1]] = found
            except AttributeError:
                found = line.split(i[1])[1]
                specified_options_dict[i[1]] = found
    return specified_options_dict


def if_proprietor_get_file(pathname):
    """Methode renvoyant l'instance de la classe File associee a un fichier

    PRE : pathname est de type str
    POST : retourne l'instance de la classe File associee au fichier ssi le fichier
        existe et qu'il appartient a l'utilisateur connecte
    RAISES :    - FileNotFoundException si le fichier n'existe pas sur la memoire locale ou distante
                - FileNotOwnedException si le fichier existe mais n'apartient pas a l'utilisateur connecte

    :param pathname: str
        Le chemin d'acces vers le fichier sur la memoire locale ou distante
    :return: object
        L'instance de la classe File associee au fichier
    """

    files = pickle_get_files()
    if pathname in files["name_id_dict"]:
        file_id = files["name_id_dict"][pathname]
        file_instance = files["objects_dict"][file_id]
        if file_id in user_instance.files:
            return file_instance
        else:
            raise FileNotOwnedException
    else:
        raise FileNotFoundException


def pickle_save(students=None, admins=None, files=None, courses=None):
    """Methode statique permettant d'enregistrer les modifications sur les classes persistantes du programme
            Seules les classes specfiees dans les parametres sont sauvegardees
    """

    if students is not None:
        with open("pickle_saves/students.pkl", 'wb') as students_file:
            pickle.dump(students, students_file)
    if admins is not None:
        with open("pickle_saves/admins.pkl", 'wb') as admins_file:
            pickle.dump(admins, admins_file)
    if files is not None:
        with open("pickle_saves/files.pkl", 'wb') as files_file:
            pickle.dump(files, files_file)
    if courses is not None:
        with open("pickle_saves/courses.pkl", 'wb') as courses_file:
            pickle.dump(courses, courses_file)


def pickle_get_students():
    """Methode statique permettant de recuperer les instances persistantes de la classe Student

    :return students : dict
        dictionnaire contenant les instances persistantes de la classe Student
    """

    with open("pickle_saves/students.pkl", 'rb') as students_file:
        students = pickle.load(students_file)

    return students


def pickle_get_admins():
    """Methode statique permettant de recuperer les instances persistantes de la classe Admin

    :return admins : dict
        dictionnaire contenant les instances persistantes de la classe Admin
    """

    with open("pickle_saves/admins.pkl", 'rb') as admins_file:
        admins = pickle.load(admins_file)

    return admins


def pickle_get_files():
    """Methode statique permettant de recuperer les instances persistantes de la classe File

    :return files : dict
        dictionnaire contenant les instances persistantes de la classe File
    """

    with open("pickle_saves/files.pkl", 'rb') as files_file:
        files = pickle.load(files_file)

    return files


def pickle_get_courses():
    """Methode statique permettant de recuperer les instances persistantes de la classe Course

    :return courses : dict
        dictionnaire contenant les instances persistantes de la classe Course
    """

    with open("pickle_saves/courses.pkl", 'rb') as courses_file:
        courses = pickle.load(courses_file)

    return courses


if __name__ == "__main__":
    username = input("Veuillez entrer votre nom d'utilisateur :")

    students = pickle_get_students()
    admins = pickle_get_admins()
    if username in students["name_id_dict"]:
        try:
            pwd = getpass.getpass("Veuillez entrer votre mot de passe :")
            user_id = students["name_id_dict"][username]
            user_instance = students["objects_dict"][user_id]
            user_instance.verify_pwd(pwd)
        except UnknownPasswordException:
            print("Le mot de passe est errone")
        else:
            Cli().cmdloop()
    elif username in admins["name_id_dict"]:
        pass
    else:
        print("Le nom d'utilisateur n'existe pas")
